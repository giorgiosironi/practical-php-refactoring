 Consolidate Duplicate Conditional Fragments
- a piece of code is contained in all legs of a conditional
-- solution: move it outside to simplify the branches
- it may seem stupid to come up with code that is duplicate in some branches, but often it is a result of a process of transforming existing code: it is not written at once like this

why?
- this refactoring is preliminary to a possible polymorphism solution
-- by minimizing the conditional code, you get help in defining what has to change between the different objects to compose
-- and you minimize the need for data or collaborators in those objects: no strange references to pass

steps
- identify duplicated code: it should be in all branches (then, else or elseif when present)
- alternatives presented by Fowler
-- code at the beginning: move it before
-- code at the end: move it after
-- code in the middle of other statements
--- first try to move it forward or backward, if it does not functionally change the result. Often the position of a statement is not strict (independence from the nearby statements)
note: code can be extracted in a method when long

example
(I'm not using fixed precision numbers, since it is money I should but it's better to keep the example short)
Invoice: add a fixed processing fee before taxes, or if there is a discount wave this fee together with it
It's not immediately clear that there's a duplicate code here:

but if we look at the logical steps, it should be: tax addition to the taxable amount should be unrelated to the presence of a discount. Let's rewrite it:

Now we see that there is a duplication. If we were to refactor to a polymorphic solution, we should take into consideration also how to compute the tax. Let's move the tax-related code out of the conditional.

The refactoring considered in this article is finished. However, I will go on in showing a simple polymorphic solution.
We introduce a Discount object, and move everything related to the conditional there (everything not related stays in the curent class, since we plan to make multiple implementation of discount)

Now we have a small object with two different behaviors depending on its state. We should really divide the logic in two classes:
